(load "~/lemmas/helpers.lisp")
(load "~/lemmas/mk.lisp")
;; When to stop early, used to prevent extra freshes from being introduced
;; (not used right now)

(defun mk-nump (e)
  (and (consp e)
       (equal (car e)
	      'MK-NUMBER)))

(defun no-recur? (e)
  (or (symbolp e)
      (numberp e)))

(defun miniKanrenize-bool (expr)
  (cond
   ((equal expr 't) `(succeed))
   ((equal expr 'nil) `(fail))
   ((and (consp expr)
	 (equal (car expr) 'consp))
    (let ((e (cadr expr))
	  (new-var (next-var))
	  (new-var1 (next-var))
	  (new-var2 (next-var)))
      `(fresh (,new-var ,new-var1 ,new-var2)
	    (conso ,new-var1 ,new-var2 ,new-var)
	    ,(miniKanrenize e new-var))))
   ((and (consp expr)
	 (equal (car expr) 'endp))
    (let ((e (cadr expr))
	  (new-var (next-var)))
      `(fresh (,new-var)
	    (== 'nil ,new-var)
	    ,(miniKanrenize e new-var))))
   ((and (consp expr)
	 (equal (car expr) 'zerop))
    (let ((e (cadr expr))
	  (new-var (next-var)))
      `(fresh (,new-var)
	    (== ,(build-num 0) ,new-var)
	    ,(miniKanrenize e new-var))))
   ((and (consp expr)
	 (equal (car expr) 'numberp))
    (let ((e (cadr expr))
	  (new-var (next-var))
	  (num (next-var)))
      `(fresh (,new-var ,num)
	    (== (cons 'MK-NUMBER ,num) ,new-var)
	    ,(miniKanrenize e new-var))))
   ((and (consp expr)
	 (equal (car expr) 'equal))
    (let ((e1 (cadr expr))
	  (e2 (caddr expr))
	  (new-var1 (next-var))
	  (new-var2 (next-var)))
      `(fresh (,new-var1 ,new-var2)
	      (== ,new-var1 ,new-var2)
	      ,(miniKanrenize e1 new-var1)
	      ,(miniKanrenize e2 new-var2))))
   ((and (consp expr)
	 (equal (car expr) 'and))
    (let ((e1 (cadr expr))
	  (e2 (caddr expr))
	  (new-var1 (next-var))
	  (new-var2 (next-var)))
      `(fresh ()
	,(miniKanrenize e1 new-var1)
	,(miniKanrenize e2 new-var2))))
   ((and (consp expr)
	 (equal (car expr) 'or))
    (let ((e1 (cadr expr))
	  (e2 (caddr expr))
	  (new-var1 (next-var))
	  (new-var2 (next-var)))
      `(disj2
	,(miniKanrenize e1 new-var1)
	,(miniKanrenize e2 new-var2))))
   (t (miniKanrenize expr t))))

(defun miniKanrenize-cond (lines dest)
  (cond
   ((endp lines) `(((fail))))
   (t (let ((line1 (car lines))
	    (rst (cdr lines)))
	(if line1
	    (let ((test (car line1))
		  (conseq (cadr line1)))
	      (cons
	       `(,(miniKanrenize-bool test)
		 ,(miniKanrenize conseq dest))
	       (miniKanrenize-cond
		rst dest)))
	  `(((fail))))))))


(defun miniKanrenize-recursion (i args final-expr dest new-name)
  (cond
   ((endp args) `((,@final-expr ,dest)))
   (t (let ((a1 (car args))
	    (rst (cdr args))
	    (arg-name (intern (concatenate 'string
					   (symbol-name new-name)
					   (get-name i)))))
	(let ((res (miniKanrenize a1 arg-name)))
	  `(,res
	    .  ,(miniKanrenize-recursion
	      (+ 1 i) rst `(,@final-expr ,arg-name) dest new-name)))))))

(defun gen-args (i n name)
  (cond
   ((= n 0) nil)
   (t (cons (intern (concatenate 'string name (get-name i)))
	    (gen-args (+ 1 i) (- n 1) name)))))

(defun miniKanrenize (expr dest)
  (cond
   ((symbolp expr) `(== ,expr ,dest))
   ((and (consp expr)
	 (equal (car expr) 'cons))
    (let ((ca (cadr expr))
	  (cd (caddr expr))
	  (new-var1 (next-var))
	  (new-var2 (next-var)))
      `(fresh (,new-var1 ,new-var2)
	      (conso ,new-var1 ,new-var2 ,dest)
	      ,(miniKanrenize ca new-var1)
	      ,(miniKanrenize cd new-var2))))
   ((and (consp expr)
	 (equal (car expr) 'car))
    (let ((pr (cadr expr))
	  (new-var (next-var)))
      `(fresh (,new-var)
	      (caro ,pr ,dest)
	      ,(miniKanrenize pr new-var))))
   ((and (consp expr)
	 (equal (car expr) 'cdr))
    (let ((pr (cadr expr))
	  (new-var (next-var)))
      `(fresh (,new-var)
	      (cdro ,new-var ,dest)
	      ,(miniKanrenize pr new-var))))
   ((and (consp expr)
	 (equal (car expr) 'append))
    (let ((l1 (cadr expr))
	  (l2 (caddr expr))
	  (new-var1 (next-var))
	  (new-var2 (next-var)))
      `(fresh (,new-var1 ,new-var2)
	      ,(miniKanrenize l1 new-var1)
	      ,(miniKanrenize l2 new-var2)
	      (appendo ,new-var1 ,new-var2 ,dest))))
   ((and (consp expr)
	 (equal (car expr) 'reverse))
    (let ((new-var (next-var))
	  (l (cadr expr)))
      `(fresh (,new-var)
	      ,(miniKanrenize l new-var)
	      (reverso ,new-var ,dest))))
   ((and (consp expr)
	 (equal (car expr) '+))
    (let ((new-var1 (next-var))
	  (new-var2 (next-var))
	  (n (cadr expr))
	  (m (caddr expr)))
      `(fresh (,new-var1 ,new-var2)
	      ,(miniKanrenize n new-var1)
	      ,(miniKanrenize m new-var2)
	      (do-pluso ,new-var1 ,new-var2 ,dest))))
   ((and (consp expr)
	 (equal (car expr) '*))
    (let ((new-var1 (next-var))
	  (new-var2 (next-var))
	  (n (cadr expr))
	  (m (caddr expr)))
      `(fresh (,new-var1 ,new-var2)
	      ,(miniKanrenize n new-var1)
	      ,(miniKanrenize m new-var2)
	      (do-timeso ,new-var1 ,new-var2 ,dest))))
   ((and (consp expr)
	 (equal (car expr) '/))
    (let ((new-var1 (next-var))
	  (new-var2 (next-var))
	  (n (cadr expr))
	  (m (caddr expr)))
      `(fresh (,new-var1 ,new-var2)
	      ,(miniKanrenize n new-var1)
	      ,(miniKanrenize m new-var2)
	      (do-/o ,new-var1 ,new-var2 ,dest))))
   ((and (consp expr)
	 (equal (car expr) 'exp))
    (let ((new-var1 (next-var))
	  (new-var2 (next-var))
	  (n (cadr expr))
	  (m (caddr expr)))
      `(fresh (,new-var1 ,new-var2)
	      ,(miniKanrenize n new-var1)
	      ,(miniKanrenize m new-var2)
	      (do-expo ,new-var1 ,new-var2 ,dest))))
   ((and (consp expr)
	 (equal (car expr) '-))
    (let ((new-var1 (next-var))
	  (new-var2 (next-var))
	  (n (cadr expr))
	  (m (caddr expr)))
      `(fresh (,new-var1 ,new-var2)
	      ,(miniKanrenize n new-var1)
	      ,(miniKanrenize m new-var2)
	      (do-minuso ,new-var1 ,new-var2 ,dest))))
   ((and (consp expr)
	 (equal (car expr) 'cond))
    `(conde . ,(miniKanrenize-cond (cdr expr) dest)))
   ((consp expr)
    (let ((new-name (get-rel-name (car expr)))
	  (num-args (len (cdr expr))))
      `(fresh ,(gen-args 0 num-args (symbol-name new-name))
	     . ,(miniKanrenize-recursion 0 (cdr expr) `(,new-name) dest new-name))))
   (t `(fail))))

(defun make-var-list (vs o)
  (cond
   ((endp vs) `(,o))
   (t (cons (car vs) (make-var-list (cdr vs) o)))))
