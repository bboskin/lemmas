(defun miniKanrenize (expr dest)
  (cond
   ((symbolp expr) `(== ,expr ,dest))
   ((and (consp expr)
	 (equal (car expr) 'cons))
    (let ((ca (cadr expr))
	  (cd (caddr expr))
	  (new-var1 (next-var))
	  (new-var2 (next-var)))
      `(fresh (,new-var1 ,new-var2)
	      (conso ,new-var1 ,new-var2 ,dest)
	      ,(miniKanrenize ca new-var1)
	      ,(miniKanrenize cd new-var2))))
   ((and (consp expr)
	 (equal (car expr) 'car))
    (let ((pr (cadr expr))
	  (new-var (next-var)))
      `(fresh (,new-var)
	      (caro ,pr ,dest)
	      ,(miniKanrenize pr new-var))))
   ((and (consp expr)
	 (equal (car expr) 'cdr))
    (let ((pr (cadr expr))
	  (new-var (next-var)))
      `(fresh (,new-var)
	      (cdro ,new-var ,dest)
	      ,(miniKanrenize pr new-var))))
   ((and (consp expr)
	 (equal (car expr) 'append))
    (let ((l1 (cadr expr))
	  (l2 (caddr expr))
	  (new-var1 (next-var))
	  (new-var2 (next-var)))
      `(fresh (,new-var1 ,new-var2)
	      ,(miniKanrenize l1 new-var1)
	      ,(miniKanrenize l2 new-var2)
	      (appendo ,new-var1 ,new-var2 ,dest))))
   ((and (consp expr)
	 (equal (car expr) 'reverse))
    (let ((new-var (next-var))
	  (l (cadr expr)))
      `(fresh (,new-var)
	      ,(miniKanrenize l new-var)
	      (reverso ,new-var ,dest))))
   ((and (consp expr)
	 (equal (car expr) '+))
    (let ((new-var1 (next-var))
	  (new-var2 (next-var))
	  (n (cadr expr))
	  (m (caddr expr)))
      `(fresh (,new-var1 ,new-var2)
	      ,(miniKanrenize n new-var1)
	      ,(miniKanrenize m new-var2)
	      (do-pluso ,new-var1 ,new-var2 ,dest))))
   ((and (consp expr)
	 (equal (car expr) '*))
    (let ((new-var1 (next-var))
	  (new-var2 (next-var))
	  (n (cadr expr))
	  (m (caddr expr)))
      `(fresh (,new-var1 ,new-var2)
	      ,(miniKanrenize n new-var1)
	      ,(miniKanrenize m new-var2)
	      (do-timeso ,new-var1 ,new-var2 ,dest))))
   ((and (consp expr)
	 (equal (car expr) '/))
    (let ((new-var1 (next-var))
	  (new-var2 (next-var))
	  (n (cadr expr))
	  (m (caddr expr)))
      `(fresh (,new-var1 ,new-var2)
	      ,(miniKanrenize n new-var1)
	      ,(miniKanrenize m new-var2)
	      (do-/o ,new-var1 ,new-var2 ,dest))))
   ((and (consp expr)
	 (equal (car expr) 'exp))
    (let ((new-var1 (next-var))
	  (new-var2 (next-var))
	  (n (cadr expr))
	  (m (caddr expr)))
      `(fresh (,new-var1 ,new-var2)
	      ,(miniKanrenize n new-var1)
	      ,(miniKanrenize m new-var2)
	      (do-expo ,new-var1 ,new-var2 ,dest))))
   ((and (consp expr)
	 (equal (car expr) '-))
    (let ((new-var1 (next-var))
	  (new-var2 (next-var))
	  (n (cadr expr))
	  (m (caddr expr)))
      `(fresh (,new-var1 ,new-var2)
	      ,(miniKanrenize n new-var1)
	      ,(miniKanrenize m new-var2)
	      (do-minuso ,new-var1 ,new-var2 ,dest))))
   ((and (consp expr)
	 (equal (car expr) 'cond))
    `(conde . ,(miniKanrenize-cond (cdr expr) dest)))
   ((consp expr)
    (let ((new-name (get-rel-name (car expr)))
	  (num-args (len (cdr expr))))
      `(fresh ,(gen-args 0 num-args (symbol-name new-name))
	     . ,(miniKanrenize-recursion 0 (cdr expr) `(,new-name) dest new-name))))
   (t `(fail))))
